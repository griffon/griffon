
[[_getting_started_console_example]]
= Console Example
:console-swing-groovy: {rootdir}/samples/console-swing-groovy

== Creating a Project

The first step is to get Lazybones installed on your system. The easiest way to achieve
this goal is to install http://gvmtool.net[GVM] first

[source]
----
$ curl -s get.gvmtool.net | bash
----

Install the latest version of Lazybones with the following command

[source]
----
$ gvm install lazybones
----

Next, add the official Griffon Lazybones templates repository to your Lazybones
configuration. Edit +$USER_HOME/.lazybones/config.groovy+ and paste the following
content

.$USER_HOME/.lazybones/config.groovy
[source,groovy,options="nowrap"]
----
bintrayRepositories = [
    "griffon/griffon-lazybones-templates",
    "pledbrook/lazybones-templates"
]
----

We're now ready to create the project. You can list all available templates with
the following command

[source]
----
$ lazybones list
Available templates in griffon/griffon-lazybones-templates:

    griffon-javafx-java
    griffon-javafx-groovy
    griffon-lanterna-java
    griffon-lanterna-groovy
    griffon-pivot-java
    griffon-pivot-groovy
    griffon-swing-java
    griffon-swing-groovy
    griffon-plugin
----

Notice that template names follow a naming convention identifying the main UI toolkit
and main programming language. Alright, let's create a simple project using Swing as
main UI toolkit and Groovy as main language

[source]
[subs="verbatim,attributes"]
----
$ lazybones create griffon-swing-groovy console
Creating project from template griffon-swing-groovy (latest) in 'console'
Define value for 'group' [org.example]: console
Define value for 'version' [0.1.0-SNAPSHOT]:
Define value for 'package' [console]:
Define value for 'griffonVersion' [{griffon-version}]:
----

[[_getting_started_console_example_layout]]
== Project Layout

Take a moment to familiarize yourself with the standard Griffon project layout.
Every Griffon project shares the same layout, making it easy to dive in as artifacts
are located in specific directories according to their responsibilities and behavior.

[source]
----
console
├── griffon-app
│   ├── conf
│   ├── controllers
│   ├── i18n
│   ├── lifecycle
│   ├── models
│   ├── resources
│   ├── services
│   └── views
└── src
    ├── integration-test
    │   └── groovy
    ├── main
    │   ├── groovy
    │   └── resources
    └── test
        ├── groovy
        └── resources
----

Griffon uses "convention over configuration" approach to enable a fast development pace.
This typically means that the name and location of files is used instead of explicit
configuration, hence you need to familiarize yourself with the directory structure provided
by Griffon.

Here is a breakdown and links to relevant sections:

 * +griffon-app+ - top level directory for Groovy sources.
 ** +conf+ - <<_overview_configuration,Configuration sources>>.
 ** +models+ - <<_models,Models>>.
 ** +views+ - <<_views,Views>>.
 ** +controllers+ - <<_controllers,Controllers>>.
 ** +services+ - <<_services,Services>>.
 ** +resources+ - <<_resources,Images, properties files, etc>>.
 ** +i18n+ - <<_internationalization,Support for internationalization (i18n)>>.
 * +src+ - Supporting sources.
 ** +main+ - Other Groovy/Java sources.
 * +test+ - <<_testing,Unit tests>>.
 * +integration-test+ - <<_testing,Integration tests>>.

Here's an screenshot of the finished application running to give you an idea of what
we're aiming at with this example . A small Groovy script has been executed, you
can see the result on the bottom right side

image::console-swing-groovy.png[Swing, 50%, 50%, align="center"]

=== Gradle

The following listing shows the Gradle build file generated by the Lazybones template

[[gradle-build-file]]
.build.gradle
[source,groovy,options="nowrap"]
[subs="verbatim,attributes"]
----
include::{console-swing-groovy}/build.gradle.txt[]
----

Alright, let's get started with the code. We'll visit the Model first.

[[_getting_started_console_example_model]]
=== Model

The model for this application is simple: it contains properties that hold the script to be
evaluated and the results of the evaluation. Make sure you paste the following code into
+griffon-app/models/console/ConsoleModel.groovy+.

.griffon-app/models/console/ConsoleModel.groovy
[source,groovy,options="nowrap"]
----
include::{console-swing-groovy}/griffon-app/models/console/ConsoleModel.groovy[lines=16..-1]
----
<1> Holds the script's text
<2> Holds the result of the script's execution
<3> Enable/disable flag

Griffon Models are *_not_* domain classes like the ones you find in Grails; they're more akin
to presentation models, and as such, they're used to transfer data between Views and Controllers.

[[_getting_started_console_example_controller]]
=== Controller

The controller is also trivial: throw the contents of the script from the model at an +Evaluator+,
then store the result back into the model. Make sure you paste the following code into
+griffon-app/controllers/console/ConsoleController.groovy+.

.griffon-app/controllers/console/ConsoleController.groovy
[source,groovy,options="nowrap"]
----
include::{console-swing-groovy}/griffon-app/controllers/console/ConsoleController.groovy[lines=16..-1]
----
<1> MVC member injected by +{link_mvc_group_manager}+
<2> Injected by JSR 330
<3> Controller action; automatically executed off the UI thread
<4> Evaluate the script
<5> Write back result to Model

The Griffon framework will inject references to the other portions of the MVC triad if fields
named +model+, +view+, and +controller+ are present in the Model, Controller or View. This allows
us to access the view widgets and the model data if needed. Any other class members annotated with
+@javax.inject.Inject+ participate in dependency injection as laid out by JSR 330, in this case the
controller will get an instance of +Evaluator+ if a suitable implementation is bound.

The +executeScript+ [conum,data-value=3]_3_ method will be used later in the View in combination
with a button. You may notice that there's no explicit threading management. All Swing developers
know they must obey the Swing Rule: long running computations must run outside of the EDT; all UI
components should be queried/modified inside the EDT. It turns out Griffon is aware of this rule,
making sure an action is called outside of the EDT by default; all bindings made to UI components
via the model will be updated inside the EDT [conum,data-value=5]_5_. We'll setup the bindings in
the next listing.

We must create a +{link_module}+ in order to bind +Evaluator+.
These are the required class definitions

.src/main/groovy/console/Evaluator.groovy
[source,groovy,options="nowrap"]
----
include::{console-swing-groovy}/src/main/groovy/console/Evaluator.groovy[lines=16..-1]
----

.src/main/groovy/console/GroovyShellEvaluator.groovy
[source,groovy,options="nowrap"]
----
include::{console-swing-groovy}/src/main/groovy/console/GroovyShellEvaluator.groovy[lines=16..-1]
----

.src/main/groovy/console/ApplicationModule.groovy
[source,groovy,options="nowrap"]
----
include::{console-swing-groovy}/src/main/groovy/console/ApplicationModule.groovy[lines=16..-1]
----
<1> Binding definition
<2> Overriding an existing binding
<3> Loaded after +swing+ module

Modules can define several bindings, even override existing bindings. In our particular
case we defined a binding [conum,data-value=1]_1_ for +Evaluator+ and overrode a
binding [conum,data-value=2]_2_ for +SwingWindowDisplayHandler+. The latter is
supplied by the +swing+ module thus we must mark it as a dependency [conum,data-value=3]_3_
in our module definition. The implementation of our custom +SwingWindowDisplayHandler+
is quite trivial, as shown by the following snippet

.src/main/groovy/console/CenteringWindowDisplayHandler.groovy
[source,groovy,options="nowrap"]
----
include::{console-swing-groovy}/src/main/groovy/console/CenteringWindowDisplayHandler.groovy[lines=16..-1]
----

This handler is only concerned with centering the window on the screen before showing it.

[[_getting_started_console_example_view]]
=== View

The view classes contain the visual components for your application. Please paste the following code
into +griffon-app/views/console/ConsoleView.groovy+.

.griffon-app/views/console/ConsoleView.groovy
[source,groovy,options="nowrap"]
----
include::{console-swing-groovy}/griffon-app/views/console/ConsoleView.groovy[lines=16..-1]
----
<1> MVC member injected by +{link_mvc_group_manager}+
<2> Bind enabled state from model
<3> Bind script source to model
<4> Apply controller action by convention
<5> Bind script result from model

The View contains a fairly straightforward SwingBuilder script. Griffon will execute these groovy
scripts in context of it's +{link_composite_builder}+.

== Running the application

Running the application requires you to execute the +run+ task if using Gradle

[source]
----
$ ./gradlew run
----

Or the +exec:java+ task if using Maven. Take special note that this task assumes classes
have been compiled already, so it's best to pair it up with +compile+ for safe measure

[source]
----
$ mvn compile exec:java
----

Now that we know the basic structure of a Griffon application and how to run it we turn
to testing.

[[_console_example_testing]]
== Testing

It's always a good idea to test out the code we write. It's pretty easy to write tests for
regular components such as +Evaluator+ and +GroovyShellEvaluator+, as they require little
to no external dependencies. Testing Griffon artifacts such as Controllers and Models on the
other hand requires a bit more of effort, but not much as shown by +ConsoleControllerTest+

.src/test/groovy/console/ConsoleControllerTest.groovy
[source,groovy,options="nowrap"]
[subs="verbatim,attributes"]
----
include::{console-swing-groovy}/src/test/groovy/console/ConsoleControllerTest.groovy[lines=16..-1]
----
<1> Indicate class under test
<2> Injected by +GriffonUnitRule+ given [conum,data-value=1]_1_
<3> Injected by +GriffonUnitRule+ via JSR 330
<4> Instantiates and configures a +GriffonAplication+ for testing
<5> Setup collaborators
<6> Stimulus
<7> Validate after waiting 2 seconds at most

At the heart we have the +@TestFor+ [conum,data-value=1]_1_ annotation and a JUnit4 rule:
+@GriffonUnitRule+ [conum,data-value=4]_4_. These two key elements are responsible for
injecting the required behavior to the test case. +@TestFor+ identifies the type of component,
a Controller in this case, that's under test; it assumes a suitable private field [conum,data-value=2]_2_
to be defined in the testcase. This field is used to inject the instance under test.
The +GriffonUnitRule+ is responsible for bootstrapping a barebones application and putting
together all the required bindings. Notice that the test case can participate in dependency
injection too [conum,data-value=3]_3_.

Running tests requires executing the +test+ task

[source]
----
$ ./gradlew test
----

A similar command can be invoked with Maven

[source]
----
$ mvn test
----

These are the basics for getting started with a Griffon project.

