
[[_getting_started_console_example]]
= Console Example
:console-swing-groovy: {rootdir}/samples/console-swing-groovy

== Creating a Project

The first step is to get Lazybones installed on your system. The easiest way to achieve
this goal is to install http://sdkman.io/[SDKMAN] first:

[source]
----
$ curl -s http://get.sdkman.io | bash
----

Install the latest version of Lazybones with the following command:

[source]
----
$ sdk install lazybones
----

Next, add the official Griffon Lazybones templates repository to your Lazybones
configuration. Edit `$USER_HOME/.lazybones/config.groovy` and paste the following
content:

.$USER_HOME/.lazybones/config.groovy
[source,groovy,linenums,options="nowrap"]
----
bintrayRepositories = [
    "griffon/griffon-lazybones-templates",
    "pledbrook/lazybones-templates"
]
----

We're now ready to create the project. You can list all available templates with
the following command:

[source]
----
$ lazybones list
Available templates in griffon/griffon-lazybones-templates:

    griffon-javafx-groovy
    griffon-javafx-java
    griffon-javafx-kotlin
    griffon-lanterna-java
    griffon-lanterna-groovy
    griffon-pivot-java
    griffon-pivot-groovy
    griffon-swing-java
    griffon-swing-groovy
    griffon-plugin
----

Notice that template names follow a naming convention identifying the main UI toolkit
and main programming language. All right, let's create a simple project using Swing as
main UI toolkit, and Groovy as main language:

[source]
[subs="attributes"]
----
$ lazybones create griffon-swing-groovy console
Creating project from template griffon-swing-groovy (latest) in 'console'
Define value for 'group' [org.example]: console
Define value for 'version' [0.1.0-SNAPSHOT]:
Define value for 'package' [console]:
Define value for 'griffonVersion' [{griffon-version}]:
----

[[_getting_started_console_example_layout]]
== Project Layout

Take a moment to familiarize yourself with the standard Griffon project layout.
Every Griffon project shares the same layout, making it easy to dive in as artifacts
are located in specific directories according to their responsibilities and behavior.

[source]
----
console
├── griffon-app
│   ├── conf
│   ├── controllers
│   ├── i18n
│   ├── lifecycle
│   ├── models
│   ├── resources
│   ├── services
│   └── views
└── src
    ├── integration-test
    │   └── groovy
    ├── main
    │   ├── groovy
    │   └── resources
    └── test
        ├── groovy
        └── resources
----

Griffon uses a "convention over configuration" approach to enable a fast development pace.
This typically means that the name and location of files are used instead of explicit
configuration, hence you need to familiarize yourself with the directory structure provided
by Griffon.

Here is a breakdown and links to relevant sections:

 * `griffon-app` - top level directory for Groovy sources.
 ** `conf` - <<_overview_configuration,Configuration sources>>.
 ** `models` - <<_models,Models>>.
 ** `views` - <<_views,Views>>.
 ** `controllers` - <<_controllers,Controllers>>.
 ** `services` - <<_services,Services>>.
 ** `resources` - <<_resources,Images, properties files, etc>>.
 ** `i18n` - <<_internationalization,Support for internationalization (i18n)>>.
 * `src` - Supporting sources.
 ** `main` - Other Groovy/Java sources.
 * `test` - <<_testing,Unit tests>>.
 * `integration-test` - <<_testing,Integration tests>>.

These conventions can be ommitted provided you reconfigure the default build files provided by
the chosen project template.

Here's a screenshot of the finished, running application to give you an idea of what
we're aiming at with this example. A small Groovy script has been executed; you
can see the result on the bottom right side:

image::console-swing-groovy.png[Swing, 50%, 50%, align="center"]

=== Gradle

The following listing shows the Gradle build file generated by the Lazybones template:

[[gradle-build-file]]
.build.gradle
[source,groovy,linenums,options="nowrap"]
[subs="verbatim,attributes"]
----
include::{console-swing-groovy}/build.gradle.txt[]
----

All right, let's get started with the code. We'll visit the Model first.

[[_getting_started_console_example_model]]
=== Model

The model for this application is simple: it contains properties that hold the script to be
evaluated and the results of the evaluation. Make sure you paste the following code into
`griffon-app/models/console/ConsoleModel.groovy`.

.griffon-app/models/console/ConsoleModel.groovy
[source,groovy,linenums,options="nowrap"]
----
include::{console-swing-groovy}/griffon-app/models/console/ConsoleModel.groovy[lines=16..-1]
----
<1> Holds the script's text
<2> Holds the result of the script's execution
<3> Enable/disable flag

Griffon Models are *_not_* domain classes like the ones you find in Grails; they're more akin
to presentation models, and as such, they're used to transfer data between Views and Controllers.

Notice the usage of the `{link_artifact_provider_for}` annotation. This annotation serves as an additional hint to the
compiler, letting it know it must generate or update a metadata file in an specific location.
The file is named after the argument set on the annotation, in this case, `griffon.core.artifact.GriffonModel`. This file
is automatically placed under `META-INF/griffon`. It's contents are fully qualified class names of types that implement
the argument set on the annotation. This results in the following file being automatically created or updated with every
compilation session

.META-INF/griffon/griffon.core.artifact.GriffonModel
[source,java,linenums,options="nowrap"]
----
console.ConsoleModel
----

You will see this annotation being used by other artifacts too albeit with different values, which will produce different
files, such as `META-INF/griffon/griffon.core.artifact.GriffonController`, `META-INF/griffon/griffon.core.artifact.GriffonView`,
and `META-INF/griffon/griffon.core.artifact.GriffonService`.

It's worth mentioning that you may skip applying this annotation, in which case you'll be responsible for creating and
updating the files mentioned earlier. These files are *very important* to the Griffon runtime, as they are used to
locate and configure all artifacts in an application.

[[_getting_started_console_example_controller]]
=== Controller

The controller is also trivial: throw the contents of the script from the model at an `Evaluator`,
then store the result back into the model. Make sure you paste the following code into
`griffon-app/controllers/console/ConsoleController.groovy`.

.griffon-app/controllers/console/ConsoleController.groovy
[source,groovy,linenums,options="nowrap"]
----
include::{console-swing-groovy}/griffon-app/controllers/console/ConsoleController.groovy[lines=16..-1]
----
<1> MVC member injected by `{link_mvc_group_manager}`
<2> Injected by JSR 330
<3> Controller action; automatically executed off the UI thread
<4> Evaluate the script
<5> Write back result to Model

The Griffon framework will inject references to the other portions of the MVC triad if fields
named `model`, `view`, and `controller` are present in the Model, Controller or View. This allows
us to access the view widgets and the model data if needed. These properties are annotated with
`@griffon.inject.MVCMember` and `@javax.annotation.Nonnull` as hints to the Griffon runtime, enabling
additional checks. Any other class members annotated with `@javax.inject.Inject` participate in
dependency injection as laid out by JSR 330, in this case the controller will get an instance of
`Evaluator` if a suitable implementation is bound.

The `executeScript` [conum,data-value=3]_3_ method will be used later in the View in combination
with a button. You may notice that there's no explicit threading management. All Swing developers
know they must obey the Swing Rule: long running computations must run outside of the EDT (Swing's
**E**vent **D**ispatch **T**hread); all UI components should be queried/modified inside the EDT. It
turns out Griffon is aware of this rule, making sure an action is called outside of the EDT by
default; all bindings made to UI components via the model will be updated inside the EDT
[conum,data-value=5]_5_. We'll setup the bindings in the next listing.

We must create a `{link_module}` in order to bind `Evaluator`.
These are the required class definitions:

.src/main/groovy/console/Evaluator.groovy
[source,groovy,linenums,options="nowrap"]
----
include::{console-swing-groovy}/src/main/groovy/console/Evaluator.groovy[lines=16..-1]
----

.src/main/groovy/console/GroovyShellEvaluator.groovy
[source,groovy,linenums,options="nowrap"]
----
include::{console-swing-groovy}/src/main/groovy/console/GroovyShellEvaluator.groovy[lines=16..-1]
----

.src/main/groovy/console/ApplicationModule.groovy
[source,groovy,linenums,options="nowrap"]
----
include::{console-swing-groovy}/src/main/groovy/console/ApplicationModule.groovy[lines=16..-1]
----
<1> Binding definition
<2> Overriding an existing binding
<3> Loaded after `swing` module
<4> Generate metadata file automatically

Modules can define several bindings, even override existing bindings. In our particular
case, we defined a binding [conum,data-value=1]_1_ for `Evaluator` and overrode a
binding [conum,data-value=2]_2_ for `SwingWindowDisplayHandler`. The latter is
supplied by the `swing` module; thus, we must mark it as a dependency [conum,data-value=3]_3_
in our module definition. Modules must be listed in a metadata file named `META-INF/services/griffon.core.injection.Module`;
this is exactly what the `@ServiceProviderFor` annotation does, by instructing the compiler that it must create or update
this particular file. This annotation is handled by the Annotation Processing tool facilities in Java via {link_jipsy} or
by AST Transformations in Groovy via {link_gipsy}. What's important to remember is that this annotation will keep the metadata
files up to date everytime a compilation session is executed.

The implementation of our custom `SwingWindowDisplayHandler` is quite trivial, as shown by the following snippet:

.src/main/groovy/console/CenteringWindowDisplayHandler.groovy
[source,groovy,linenums,options="nowrap"]
----
include::{console-swing-groovy}/src/main/groovy/console/CenteringWindowDisplayHandler.groovy[lines=16..-1]
----

This handler is only concerned with centering the window on the screen before showing it.

[[_getting_started_console_example_view]]
=== View

The view classes contain the visual components for your application. Please paste the following code
into `griffon-app/views/console/ConsoleView.groovy`.

.griffon-app/views/console/ConsoleView.groovy
[source,groovy,linenums,options="nowrap"]
----
include::{console-swing-groovy}/griffon-app/views/console/ConsoleView.groovy[lines=16..-1]
----
<1> MVC member injected by `{link_mvc_group_manager}`
<2> Bind enabled state from model
<3> Bind script source to model
<4> Apply controller action by convention
<5> Bind script result from model

The View contains a fairly straightforward SwingBuilder script. Griffon will execute these groovy
scripts in context of its `{link_composite_builder}`.

== Running the application

Running the application requires you to execute the `run` task if using Gradle:

[source]
----
$ ./gradlew run
----

Or the `exec:java` plugin goal if using Maven. Take special note that this goal assumes classes
have been compiled already, so it's best to pair it up with `compile` for safe measure. Or better
yet, use the pre-configured `run` profile, like so

[source]
----
$ mvn -Prun
----

Now that we know the basic structure of a Griffon application and how to run it, we turn
to testing.

[[_console_example_testing]]
== Testing

It's always a good idea to test out the code we write. It's pretty easy to write tests for
regular components such as `Evaluator` and `GroovyShellEvaluator`, as they require little
or no external dependencies. Testing Griffon artifacts such as Controllers and Models on the
other hand requires a bit more of effort, but not much, as shown by `ConsoleControllerTest`:

.src/test/groovy/console/ConsoleControllerTest.groovy
[source,groovy,linenums,options="nowrap"]
----
include::{console-swing-groovy}/src/test/groovy/console/ConsoleControllerTest.groovy[lines=16..-1]
----
<1> Indicate class under test
<2> Injected by `GriffonUnitRule` given [conum,data-value=1]_1_
<3> Injected by `GriffonUnitRule` via JSR 330
<4> Instantiates and configures a `GriffonAplication` for testing
<5> Setup collaborators
<6> Stimulus
<7> Validate after waiting 2 seconds at most

At the heart, we have the `@TestFor` [conum,data-value=1]_1_ annotation and a JUnit4 rule:
`@GriffonUnitRule` [conum,data-value=4]_4_. These two key elements are responsible for
injecting the required behavior into the test case. `@TestFor` identifies the type of component,
a Controller in this case, which is under test; it assumes a suitable private field [conum,data-value=2]_2_
to be defined in the testcase. This field is used to inject the instance under test.
The `GriffonUnitRule` is responsible for bootstrapping a barebones application and putting
together all the required bindings. Notice that the test case can participate in dependency
injection too [conum,data-value=3]_3_.

Running tests requires executing the `test` task:

[source]
----
$ ./gradlew test
----

A similar command can be invoked with Maven:

[source]
----
$ mvn test
----

These are the basics for getting started with a Griffon project.

