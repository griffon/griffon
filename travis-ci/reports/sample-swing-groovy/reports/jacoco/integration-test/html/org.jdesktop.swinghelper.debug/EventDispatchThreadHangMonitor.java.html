<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>EventDispatchThreadHangMonitor.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sample-swing-groovy</a> &gt; <a href="index.source.html" class="el_package">org.jdesktop.swinghelper.debug</a> &gt; <span class="el_source">EventDispatchThreadHangMonitor.java</span></div><h1>EventDispatchThreadHangMonitor.java</h1><pre class="source lang-java linenums">/*
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

package org.jdesktop.swinghelper.debug;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.awt.AWTEvent;
import java.awt.EventQueue;
import java.awt.Toolkit;
import java.awt.event.WindowEvent;
import java.lang.management.ManagementFactory;
import java.lang.management.ThreadInfo;
import java.lang.management.ThreadMXBean;
import java.util.LinkedList;
import java.util.Timer;
import java.util.TimerTask;

import static griffon.core.GriffonExceptionHandler.sanitize;


/**
 * Monitors the AWT event dispatch thread for events that take longer than
 * a certain time to be dispatched.
 * &lt;p/&gt;
 * The principle is to record the time at which we start processing an event,
 * and have another thread check frequently to see if we're still processing.
 * If the other thread notices that we've been processing a single event for
 * too long, it prints a stack trace showing what the event dispatch thread
 * is doing, and continues to time it until it finally finishes.
 * &lt;p/&gt;
 * This is useful in determining what code is causing your Java application's
 * GUI to be unresponsive.
 * &lt;p/&gt;
 * &lt;p&gt;The original blog can be found here&lt;br&gt;
 * &lt;a href=&quot;http://elliotth.blogspot.com/2005/05/automatically-detecting-awt-event.html&quot;&gt;
 * Automatically detecting AWT event dispatch thread hangs&lt;/a&gt;
 * &lt;/p&gt;
 *
 * @author Elliott Hughes &lt;enh@jessies.org&gt;
 *         &lt;p/&gt;
 *         Advice, bug fixes, and test cases from
 *         Alexander Potochkin and Oleg Sukhodolsky.
 *         &lt;p/&gt;
 *         https://swinghelper.dev.java.net/
 */
public final class EventDispatchThreadHangMonitor extends EventQueue {
<span class="fc" id="L62">    private static final Logger LOG = LoggerFactory.getLogger(EventDispatchThreadHangMonitor.class);</span>
<span class="fc" id="L63">    private static final EventDispatchThreadHangMonitor INSTANCE = new EventDispatchThreadHangMonitor();</span>

    // Time to wait between checks that the event dispatch thread isn't hung.
    private static final long CHECK_INTERVAL_MS = 100;

    // Maximum time we won't warn about. This used to be 500 ms, but 1.5 on
    // late-2004 hardware isn't really up to it; there are too many parts of
    // the JDK that can go away for that long (often code that has to be
    // called on the event dispatch thread, like font loading).
    private static final long UNREASONABLE_DISPATCH_DURATION_MS = 1000;

    // Help distinguish multiple hangs in the log, and match start and end too.
    // Only access this via getNewHangNumber.
<span class="fc" id="L76">    private static int hangCount = 0;</span>

    // Prevents us complaining about hangs during start-up, which are probably
    // the JVM vendor's fault.
<span class="fc" id="L80">    private boolean haveShownSomeComponent = false;</span>

    // The currently outstanding event dispatches. The implementation of
    // modal dialogs is a common cause for multiple outstanding dispatches.
<span class="fc" id="L84">    private final LinkedList&lt;DispatchInfo&gt; dispatches = new LinkedList&lt;&gt;();</span>

    // Time to wait before warning of slow operation
<span class="fc" id="L87">    private long timeout = UNREASONABLE_DISPATCH_DURATION_MS;</span>

    private static class DispatchInfo {
        // The last-dumped hung stack trace for this dispatch.
        private StackTraceElement[] lastReportedStack;
        // If so; what was the identifying hang number?
        private int hangNumber;

        // The EDT for this dispatch (for the purpose of getting stack traces).
        // I don't know of any API for getting the event dispatch thread,
        // but we can assume that it's the current thread if we're in the
        // middle of dispatching an AWT event...
        // We can't cache this because the EDT can die and be replaced by a
        // new EDT if there's an uncaught exception.
<span class="fc" id="L101">        private final Thread eventDispatchThread = Thread.currentThread();</span>

        // The last time in milliseconds at which we saw a dispatch on the above thread.
<span class="fc" id="L104">        private long lastDispatchTimeMillis = System.currentTimeMillis();</span>

        private final long timeout;

<span class="fc" id="L108">        public DispatchInfo(long timeout) {</span>
            // All initialization is done by the field initializers.
<span class="fc" id="L110">            this.timeout = timeout;</span>
<span class="fc" id="L111">        }</span>

        public void checkForHang() {
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">            if (timeSoFar() &gt; timeout) {</span>
<span class="nc" id="L115">                examineHang();</span>
            }
<span class="fc" id="L117">        }</span>

        // We can't use StackTraceElement.equals because that insists on checking the filename and line number.
        // That would be version-specific.
        private static boolean stackTraceElementIs(StackTraceElement e, String className, String methodName, boolean isNative) {
<span class="nc bnc" id="L122" title="All 6 branches missed.">            return e.getClassName().equals(className) &amp;&amp; e.getMethodName().equals(methodName) &amp;&amp; e.isNativeMethod() == isNative;</span>
        }

        // Checks whether the given stack looks like it's waiting for another event.
        // This relies on JDK implementation details.
        private boolean isWaitingForNextEvent(StackTraceElement[] currentStack) {
<span class="nc bnc" id="L128" title="All 6 branches missed.">            return stackTraceElementIs(currentStack[0], &quot;java.lang.Object&quot;, &quot;wait&quot;, true) &amp;&amp; stackTraceElementIs(currentStack[1], &quot;java.lang.Object&quot;, &quot;wait&quot;, false) &amp;&amp; stackTraceElementIs(currentStack[2], &quot;java.awt.EventQueue&quot;, &quot;getNextEvent&quot;, false);</span>
        }

        private void examineHang() {
<span class="nc" id="L132">            StackTraceElement[] currentStack = sanitize(eventDispatchThread.getStackTrace());</span>

<span class="nc bnc" id="L134" title="All 2 branches missed.">            if (isWaitingForNextEvent(currentStack)) {</span>
                // Don't be fooled by a modal dialog if it's waiting for its next event.
                // As long as the modal dialog's event pump doesn't get stuck, it's okay for the outer pump to be suspended.
<span class="nc" id="L137">                return;</span>
            }

<span class="nc bnc" id="L140" title="All 2 branches missed.">            if (stacksEqual(lastReportedStack, currentStack)) {</span>
                // Don't keep reporting the same hang every time the timer goes off.
<span class="nc" id="L142">                return;</span>
            }

<span class="nc" id="L145">            hangNumber = getNewHangNumber();</span>
<span class="nc" id="L146">            String stackTrace = stackTraceToString(currentStack);</span>
<span class="nc" id="L147">            lastReportedStack = currentStack;</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">            if (LOG.isWarnEnabled()) {</span>
<span class="nc" id="L149">                LOG.warn(&quot;(hang #&quot; + hangNumber + &quot;) event dispatch thread stuck processing event for &quot; + timeSoFar() + &quot; ms:&quot; + stackTrace);</span>
            }
<span class="nc" id="L151">            checkForDeadlock();</span>
<span class="nc" id="L152">        }</span>

        private static boolean stacksEqual(StackTraceElement[] a, StackTraceElement[] b) {
<span class="nc bnc" id="L155" title="All 2 branches missed.">            if (a == null) {</span>
<span class="nc" id="L156">                return false;</span>
            }
<span class="nc bnc" id="L158" title="All 2 branches missed.">            if (a.length != b.length) {</span>
<span class="nc" id="L159">                return false;</span>
            }
<span class="nc bnc" id="L161" title="All 2 branches missed.">            for (int i = 0; i &lt; a.length; ++i) {</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">                if (!a[i].equals(b[i])) {</span>
<span class="nc" id="L163">                    return false;</span>
                }
            }
<span class="nc" id="L166">            return true;</span>
        }

        /**
         * Returns how long this dispatch has been going on (in milliseconds).
         */
        private long timeSoFar() {
<span class="fc" id="L173">            return (System.currentTimeMillis() - lastDispatchTimeMillis);</span>
        }

        public void dispose() {
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">            if (lastReportedStack != null) {</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">                if (LOG.isWarnEnabled()) {</span>
<span class="nc" id="L179">                    LOG.warn(&quot;(hang #&quot; + hangNumber + &quot;) event dispatch thread unstuck after &quot; + timeSoFar() + &quot; ms.&quot;);</span>
                }
            }
<span class="fc" id="L182">        }</span>
    }

<span class="fc" id="L185">    private EventDispatchThreadHangMonitor() {</span>
<span class="fc" id="L186">        initTimer();</span>
<span class="fc" id="L187">    }</span>

    /**
     * Sets up a timer to check for hangs frequently.
     */
    private void initTimer() {
<span class="fc" id="L193">        final long initialDelayMs = 0;</span>
<span class="fc" id="L194">        final boolean isDaemon = true;</span>
<span class="fc" id="L195">        Timer timer = new Timer(&quot;EventDispatchThreadHangMonitor&quot;, isDaemon);</span>
<span class="fc" id="L196">        timer.schedule(new HangChecker(), initialDelayMs, CHECK_INTERVAL_MS);</span>
<span class="fc" id="L197">    }</span>

<span class="fc" id="L199">    private class HangChecker extends TimerTask {</span>
        @Override
        public void run() {
<span class="fc" id="L202">            synchronized (dispatches) {</span>
<span class="fc bfc" id="L203" title="All 4 branches covered.">                if (dispatches.isEmpty() || !haveShownSomeComponent) {</span>
                    // Nothing to do.
                    // We don't destroy the timer when there's nothing happening
                    // because it would mean a lot more work on every single AWT
                    // event that gets dispatched.
<span class="fc" id="L208">                    return;</span>
                }
                // Only the most recent dispatch can be hung; nested dispatches
                // by their nature cause the outer dispatch pump to be suspended.
<span class="fc" id="L212">                dispatches.getLast().checkForHang();</span>
<span class="pc" id="L213">            }</span>
<span class="fc" id="L214">        }</span>
    }

    /**
     * Sets up hang detection for the event dispatch thread.
     */
    public static void initMonitoring() {
<span class="fc" id="L221">        Toolkit.getDefaultToolkit().getSystemEventQueue().push(INSTANCE);</span>
<span class="fc" id="L222">    }</span>

    public static EventDispatchThreadHangMonitor getInstance() {
<span class="nc" id="L225">        return INSTANCE;</span>
    }

    public long getTimeout() {
<span class="nc" id="L229">        return timeout;</span>
    }

    public void setTimeout(long timeout) {
<span class="nc bnc" id="L233" title="All 2 branches missed.">        this.timeout = timeout &gt; UNREASONABLE_DISPATCH_DURATION_MS ? timeout : UNREASONABLE_DISPATCH_DURATION_MS;</span>
<span class="nc" id="L234">    }</span>

    /**
     * Overrides EventQueue.dispatchEvent to call our pre and post hooks either
     * side of the system's event dispatch code.
     */
    @Override
    protected void dispatchEvent(AWTEvent event) {
        try {
<span class="fc" id="L243">            preDispatchEvent();</span>
<span class="fc" id="L244">            super.dispatchEvent(event);</span>
        } finally {
<span class="pc" id="L246">            postDispatchEvent();</span>
<span class="pc bpc" id="L247" title="4 of 8 branches missed.">            if (!haveShownSomeComponent &amp;&amp;</span>
<span class="pc bpc" id="L248" title="2 of 4 branches missed.">                event instanceof WindowEvent &amp;&amp; event.getID() == WindowEvent.WINDOW_OPENED) {</span>
<span class="pc" id="L249">                haveShownSomeComponent = true;</span>
            }
        }
<span class="fc" id="L252">    }</span>

    /**
     * Starts tracking a dispatch.
     */
    private synchronized void preDispatchEvent() {
<span class="fc" id="L258">        synchronized (dispatches) {</span>
<span class="fc" id="L259">            dispatches.addLast(new DispatchInfo(timeout));</span>
<span class="pc" id="L260">        }</span>
<span class="fc" id="L261">    }</span>

    /**
     * Stops tracking a dispatch.
     */
    private synchronized void postDispatchEvent() {
<span class="fc" id="L267">        synchronized (dispatches) {</span>
            // We've finished the most nested dispatch, and don't need it any longer.
<span class="fc" id="L269">            DispatchInfo justFinishedDispatch = dispatches.removeLast();</span>
<span class="fc" id="L270">            justFinishedDispatch.dispose();</span>

            // The other dispatches, which have been waiting, need to be credited extra time.
            // We do this rather simplistically by pretending they've just been redispatched.
<span class="fc" id="L274">            Thread currentEventDispatchThread = Thread.currentThread();</span>
<span class="fc bfc" id="L275" title="All 2 branches covered.">            for (DispatchInfo dispatchInfo : dispatches) {</span>
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">                if (dispatchInfo.eventDispatchThread == currentEventDispatchThread) {</span>
<span class="fc" id="L277">                    dispatchInfo.lastDispatchTimeMillis = System.currentTimeMillis();</span>
                }
<span class="fc" id="L279">            }</span>
<span class="pc" id="L280">        }</span>
<span class="fc" id="L281">    }</span>

    private static void checkForDeadlock() {
<span class="nc" id="L284">        ThreadMXBean threadBean = ManagementFactory.getThreadMXBean();</span>
<span class="nc" id="L285">        long[] threadIds = threadBean.findMonitorDeadlockedThreads();</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">        if (threadIds == null) {</span>
<span class="nc" id="L287">            return;</span>
        }
<span class="nc bnc" id="L289" title="All 2 branches missed.">        if (LOG.isWarnEnabled()) {</span>
<span class="nc" id="L290">            StringBuilder b = new StringBuilder(&quot;Deadlock detected involving the following threads:&quot;);</span>
<span class="nc" id="L291">            ThreadInfo[] threadInfos = threadBean.getThreadInfo(threadIds, Integer.MAX_VALUE);</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">            for (ThreadInfo info : threadInfos) {</span>
<span class="nc" id="L293">                b.append(&quot;Thread #&quot;)</span>
<span class="nc" id="L294">                    .append(info.getThreadId())</span>
<span class="nc" id="L295">                    .append(&quot; &quot;)</span>
<span class="nc" id="L296">                    .append(info.getThreadName())</span>
<span class="nc" id="L297">                    .append(&quot; (&quot;)</span>
<span class="nc" id="L298">                    .append(info.getThreadState()).</span>
<span class="nc" id="L299">                    append(&quot;) waiting on &quot;)</span>
<span class="nc" id="L300">                    .append(info.getLockName())</span>
<span class="nc" id="L301">                    .append(&quot; held by &quot;)</span>
<span class="nc" id="L302">                    .append(info.getLockOwnerName())</span>
<span class="nc" id="L303">                    .append(stackTraceToString(sanitize(info.getStackTrace())));</span>
            }
<span class="nc" id="L305">            LOG.warn(b.toString());</span>
        }
<span class="nc" id="L307">    }</span>

    private static String stackTraceToString(StackTraceElement[] stackTrace) {
<span class="nc" id="L310">        StringBuilder result = new StringBuilder();</span>
        // We used to avoid showing any code above where this class gets
        // involved in event dispatch, but that hides potentially useful
        // information when dealing with modal dialogs. Maybe we should
        // reinstate that, but search from the other end of the stack?
<span class="nc bnc" id="L315" title="All 2 branches missed.">        for (StackTraceElement stackTraceElement : stackTrace) {</span>
<span class="nc" id="L316">            String indentation = &quot;    &quot;;</span>
<span class="nc" id="L317">            result.append(&quot;\n&quot;).append(indentation).append(stackTraceElement);</span>
        }
<span class="nc" id="L319">        return result.toString();</span>
    }

    private synchronized static int getNewHangNumber() {
<span class="nc" id="L323">        return ++hangCount;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.3.201502191951</span></div></body></html>